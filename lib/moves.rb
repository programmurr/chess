require_relative 'move_formulas'

# This class is doing far too much and the methods are far too complicated
#    Get the BFS running for #cells_between_start_and_end_cells - DONE 9/22
#    Compare that array to the move array generated by the player/piece - IN PROGRESS
#    Once working, refactor refactor refactor
class Moves
  attr_accessor :temp_queue, :final_queue, :count
  attr_reader :player, :board, :start_cell, :end_cell, :piece, :start_co_ords, :end_co_ords

  def initialize(player, board)
    @player = player
    @piece = player.piece
    @board = board
    @start_cell = get_start_cell(player, board)
    @end_cell = get_end_cell(player, board)
    @start_co_ords = get_start_co_ords(player, board)
    @end_co_ords = get_end_co_ords(player, board)
    @temp_queue = []
    @final_queue = []
    @count = 1
  end

  # BFS to get the cells from the start cell to the end cell as an array
  def cells_between_start_and_end_cells
    end_cell.counter = 0
    temp_queue << end_cell
    final_queue << end_cell
    start_adjascent_array = start_cell.adjascent_cells(start_co_ords, [])
    end_adjascent_array = end_cell.adjascent_cells(end_co_ords, [])
    map_finish_to_start(end_adjascent_array, start_adjascent_array)
    start_cell.counter = count + 1
    cells_containing_path = remove_empty_cells
    start_adjascent_cells = get_cells_from_possible_moves(start_adjascent_array, board)
    path = move_to_end_cell(cells_containing_path, start_adjascent_cells)
    reset_cell_counters
    self.count = 1
    cells_containing_path
  end

  def reset_cell_counters
    board.grid.each do |row|
      row.each { |cell| cell.counter = nil }
    end
  end

  def move_to_end_cell(cells_containing_path, start_adjascent_cells)
    return_array = []
    current_cell = start_cell
    next_possible_cells = start_adjascent_cells.select { |cell| cell.counter != nil && cell.counter < current_cell.counter }
    loop do
      current_cell = next_possible_cells.sample
      return_array << current_cell
      break if current_cell.co_ord == end_cell.co_ord
      
      next_possible_co_ords = current_cell.adjascent_cells(board.get_cell_grid_co_ord(current_cell.co_ord), [])
      next_possible_cells = get_cells_from_possible_moves(next_possible_co_ords, board)
      next_possible_cells.select! { |cell| cell.counter != nil && cell.counter < current_cell.counter }
    end
    return_array
  end

  def start_positions(cells_containing_path, start_adjascent_array)
    return_array = []
    cells_containing_path.each do |cell|
      start_adjascent_array.each do |move|
        return_array << cell if cell.co_ord == move
      end
    end
    return_array
  end


  def remove_empty_cells
    return_array = []
    board.grid.each do |row|
      row.each do |cell|
        return_array << cell if cell.counter != nil
      end
    end
    return_array
  end


  # Make private in future
  def map_finish_to_start(end_adjascent_array, start_adjascent_array)
    loop do
      push_cells_to_temp_queue(end_adjascent_array)
      queue_check
      self.final_queue = remove_elements(final_queue)
      self.temp_queue = remove_elements(temp_queue)
      temp_queue.shift
      append_to_final_queue
      break if path_discovered?(start_adjascent_array, end_adjascent_array)
      
      end_adjascent_array = renew_end_adjascent_array
      self.count += 1
    end
  end

  def renew_end_adjascent_array
    return_array = []
    board.grid.each do |row|
      row.each do |cell|
        adjascent_array = cell.adjascent_cells(board.get_cell_grid_co_ord(cell.co_ord), [])
        adjascent_cells = get_cells_from_possible_moves(adjascent_array, board)
        if cell.counter == count
          adjascent_cells.each.with_index { |_adj_cell, index| return_array << adjascent_array[index] }
        end
      end
    end
    return_array.uniq
  end


  def push_cells_to_temp_queue(adjascent_array)
    cells = get_cells_from_possible_moves(adjascent_array, board)
    cells.each do |cell|
      cell.counter = count if cell.counter.nil?
      temp_queue << cell
    end
  end

  def queue_check
    final_queue.each do |final_cell|
      temp_queue.each do |temp_cell|
        if final_cell.co_ord == temp_cell.co_ord && final_cell.counter < temp_cell.counter
          temp_cell.remove = true
        elsif final_cell.co_ord == temp_cell.co_ord && final_cell.counter > temp_cell.counter
          final_cell.remove = true
        end
      end
    end
  end

  def remove_elements(queued_cells)
    return_array = []
    queued_cells.each do |cell|
      return_array << cell if cell.remove == false
    end
    return_array
  end

  def append_to_final_queue
    temp_queue.each do |cell|
      final_queue << cell
    end
  end

  def path_discovered?(start_adjascent_array, end_adjascent_array)
    start_adjascent_array.each do |start_co_ord|
      end_adjascent_array.each do |end_co_ord|
        return true if start_co_ord == end_co_ord
      end
    end
    false
  end


  # May split this into a method just for rooks, bishops and queens
  #   Make a separate method for the other pieces
  def valid_move?
    # Immediately return false if the end cell color is the same as the player's color
    return false if start_and_end_cells_same_color?
    path_cells = cells_between_start_and_end_cells
    selected_piece_class_name = start_cell.value.class.to_s
    total_moves = all_moves(start_co_ords, selected_piece_class_name)
    possible_moves = remove_moves_beyond_the_board(total_moves)
    cells = get_cells_from_possible_moves(possible_moves, board)
    cells_backup = Marshal.load(Marshal.dump(cells))
    path_hash = make_hash_of_path_cells(path_cells, cells)
    filter_cells_with_pieces(cells)
    return true if does_path_match_cells?(path_hash, cells)

    return false
    # chopped_cells = chop_cells_blocked_by_a_piece(cells, cells_backup)
    if contains_end_cell?(chopped_cells, end_cell) == false
      return false
    elsif contains_end_cell?(chopped_cells, end_cell)
      return true
    end
    return false if cells.length.zero?

    cells.select! { |cell| cell.co_ord == end_cell.co_ord }
    return false if cells.length.zero?

    true
  end

  private

  def make_hash_of_path_cells(path_cells, cells)
    return_hash = {}
    cells.each_key { |key| return_hash[key] = [] }
    path_cells.each do |cell|
      cells.each do |direction, move|
        binding.pry
        return_hash[direction] << cell if move.include?(cell)
      end
    end
    return_hash.reject { |_direction, moves| moves.empty? }
  end

  def does_path_match_cells?(path_hash, cells)
    path_hash.each_value do |return_move|
      cells.each_value do |cell|
        return true if return_move.difference(cell) == [] && return_move.include?(end_cell)
      end
    end
    false
    # sepearate only matching directions
    # do those directions contain end cell?
  end

  def start_and_end_cells_same_color?
    return true if start_cell.value.color == end_cell.value.color
  rescue NoMethodError
    false
  end

  # Works for hash, not arrays i.e. only for rook, bishop and queen
  def contains_end_cell?(chopped_cells, end_cell)
    chopped_cells.each do |key, value|
      return true if chopped_cells[key].include?(end_cell)
    end
    false
  end

  # Works for hash, not arrays i.e. only for rook, bishop and queen
  def chop_cells_blocked_by_a_piece(cells, cells_backup)
    return_hash = {}
    cells.each_key do |key|
      if cells[key].length == cells_backup[key].length
        return_hash[key] = cells[key]
      end
    end
    return_hash
  end

  def all_moves(co_ord, class_name)
    moves_hash = { 'Pawn' => pawn(co_ord),
                   'Rook' => MoveFormulas.new(co_ord).rook,
                   'Bishop' => MoveFormulas.new(co_ord).bishop,
                   'Knight' => MoveFormulas.new(co_ord).knight,
                   'Queen' => MoveFormulas.new(co_ord).queen,
                   'King' => MoveFormulas.new(co_ord).king }
    moves_hash.fetch(class_name)
  end

  # HACK: Keep an eye for when I can refactor this into #all_moves
  def pawn(co_ord)
    if start_cell.value.color == 'White'
      MoveFormulas.new(co_ord).white_pawn
    elsif start_cell.value.color == 'Black'
      MoveFormulas.new(co_ord).black_pawn
    end
  end

  def get_end_co_ords(player, board)
    board.get_cell_grid_co_ord(player.move[1])
  end

  def get_start_co_ords(player, board)
    board.get_cell_grid_co_ord(player.move[0])
  end

  def get_start_cell(player, board)
    board.get_cell(player.move[0])
  end

  def get_end_cell(player, board)
    board.get_cell(player.move[1])
  end

  def filter_cells_from_hash(cells)
    cells.each_value do |positions|
      positions.select! { |cell| cell.value.nil? }
    end
  end

  def filter_cells_with_pieces(cells)
    if cells.class == Hash
      filter_cells_from_hash(cells)
    else
      cells.select! { |cell| cell.value.nil? }
    end
  end

  def remove_hash_moves_beyond_board(total_moves)
    possible_hash = {}
    total_moves.each_key { |key| possible_hash[key] = [] }
    total_moves.each do |direction, positions|
      positions.each do |co_ord|
        next unless co_ord[0] < 8 && co_ord[1] < 8

        possible_hash[direction] << co_ord if !co_ord[0].negative? && !co_ord[1].negative?
      end
    end
    possible_hash
  end

  def remove_moves_beyond_the_board(total_moves)
    if total_moves.class == Hash
      remove_hash_moves_beyond_board(total_moves)
    else
      possible_array = []
      total_moves.each do |co_ord|
        next unless co_ord[0] < 8 && co_ord[1] < 8

        possible_array << co_ord if !co_ord[0].negative? && !co_ord[1].negative?
      end
      possible_array
    end
  end

  def get_cells_from_hash(possible_moves, board)
    possible_moves.each_value do |positions|
      positions.map! { |co_ord| board.get_cell_string_co_ord(co_ord) }
      positions.map! { |co_ord| board.get_cell(co_ord) }
    end
  end

  def get_cells_from_possible_moves(possible_moves, board)
    if possible_moves.class == Hash
      get_cells_from_hash(possible_moves, board)
    else
      cell_strings = possible_moves.map { |co_ord| board.get_cell_string_co_ord(co_ord) }
      cell_strings.map { |co_ord| board.get_cell(co_ord) }
    end
  end
end
